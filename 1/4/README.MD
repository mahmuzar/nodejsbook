Node.js часто называют «однопоточным», но это упрощение. Чтобы понять, почему он одновременно однопоточный и масштабируемый, нужно разобраться в его архитектуре.
____

## Однопоточная модель выполнения JavaScript

- Код на JavaScript в Node.js исполняется в одном основном потоке (main thread).
- Это значит, что ваше приложение не создаёт отдельный поток для каждого нового запроса, как это делают, например, Java- или PHP-серверы.
- Все синхронные операции (например, for, while, сложные вычисления) блокируют этот поток — и пока они выполняются, Node.js не может обрабатывать другие запросы.

## Асинхронность и неблокирующий ввод-вывод

- Node.js построен на событийной модели (event loop) и использует неблокирующие операции ввода-вывода (I/O): работа с файлами, сетевые запросы, базы данных и т.д.
- Когда вы делаете, например, запрос к БД через fs.readFile или fetch, Node.js не ждёт ответа — он отдаёт задачу системе (через библиотеку libuv) и продолжает обрабатывать другие запросы.
- Как только операция завершается, соответствующий колбэк или промис ставится в очередь событий, и event loop выполняет его, когда основной поток свободен.

> Это позволяет обрабатывать тысячи одновременных подключений с минимальным потреблением памяти и без переключения между потоками.

## Масштабируемость

- Высокой эффективности при I/O-нагрузках: идеален для чатов, API, стриминга — где много ожиданий, но мало CPU-нагрузки.
- Кластеризации: хотя основной JS-код однопоточный, вы можете запускать несколько процессов Node.js (например, один на ядро CPU) через встроенный модуль cluster.
- Интеграции с внешними сервисами: тяжёлые вычисления можно выносить в отдельные микросервисы, очереди задач (RabbitMQ, Kafka) или воркеры.
____

## Важное уточнение:

- Однопоточный — не значит "одноядерный": благодаря libuv, операции вроде чтения файлов или сетевых запросов выполняются в пуле потоков на уровне ОС, но результаты возвращаются в основной поток.
- CPU-интенсивные задачи (например, шифрование, обработка изображений) действительно блокируют event loop — для них используют worker_threads или выносят логику за пределы основного процесса.

## Итог

Node.js однопоточный в плане выполнения JavaScript-кода, но масштабируемый благодаря асинхронности, неблокирующему I/O и архитектуре на основе event loop. Это делает его отличным выбором для I/O-интенсивных, а не CPU-интенсивных приложений.