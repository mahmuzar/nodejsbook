Обеспечение отказоустойчивости (fault tolerance) микросервиса на Node.js — ключевая задача при построении надёжных распределённых систем. Вот основные подходы и практики, которые помогут достичь высокой доступности и устойчивости к сбоям:
____

## Содержание

1. [Изоляция сбоев (Failure Isolation)](#-Изоляция-сбоев-Failure-Isolation)
1. [Повторные попытки с экспоненциальной задержкой (Retry with Backoff)](#-Повторные-попытки-с-экспоненциальной-задержкой-Retry-with-Backoff)
1. [Таймауты на всех уровнях](#-Таймауты-на-всех-уровнях)
1. [Мониторинг и логирование](#-Мониторинг-и-логирование)
1. [Горизонтальное масштабирование и балансировка](#-Горизонтальное-масштабирование-и-балансировка)
1. [Health Checks](#-Health-Checks)
1. [Использование очередей (Message Queues)](#-Использование-очередей-Message-Queues)
1. [Тестирование отказоустойчивости](#-Тестирование-отказоустойчивости)
1. [Архитектурные рекомендации](#-Архитектурные-рекомендации)

## [↑](#Содержание) Изоляция сбоев (Failure Isolation)

- Используйте паттерн Circuit Breaker
- Библиотеки: opossum, cockatiel.
- Они предотвращают каскадные сбои, когда один зависший или медленный сервис «тянет за собой» всю систему.
- Bulkheads (перегородки)
- Ограничьте ресурсы (например, пул соединений к БД или количество воркеров), выделенные для отдельных внешних зависимостей, чтобы сбой в одном компоненте не исчерпал все ресурсы приложения.

## [↑](#Содержание) Повторные попытки с экспоненциальной задержкой (Retry with Backoff)

- Не пытайтесь повторять сразу — используйте экспоненциальную задержку и jitter, чтобы избежать шторма запросов.
- Ограничьте число попыток (обычно 2–3).
- Используйте библиотеки: axios-retry, p-retry, или реализуйте вручную.

> ⚠️ Не применяйте retry для идемпотентно-небезопасных операций (например, POST без idempotency key).

## [↑](#Содержание) Таймауты на всех уровнях

- Устанавливайте разумные таймауты:
    - HTTP-клиенты (axios, fetch): timeout
    - Базы данных: connectionTimeout, queryTimeout
    - Внешние вызовы: ограничьте время ожидания ответа
- Это предотвращает «зависание» сервиса при медленном ответе зависимости.

## [↑](#Содержание) Мониторинг и логирование

- Интегрируйте:
    - Логирование (например, pino + winston)
    - Метрики (Prometheus + Grafana)
    - Трассировка (OpenTelemetry, Jaeger)
- Отслеживайте:
    - Количество ошибок
    - Время ответа
    - Состояние Circuit Breaker
    - Потребление памяти/CPU

## [↑](#Содержание) Горизонтальное масштабирование и балансировка

- Запускайте несколько экземпляров сервиса через PM2, Docker + Kubernetes, или systemd.
- Используйте балансировщик нагрузки (Nginx, HAProxy, или облачный LB).
- Это позволяет пережить сбой одного инстанса.

## [↑](#Содержание) Health Checks

- Реализуйте эндпоинты /health и /ready:
    - /health — проверяет, жив ли процесс
    - /ready — проверяет, готов ли сервис обрабатывать трафик (например, есть ли подключение к БД)
- Используется оркестраторами (Kubernetes) для управления жизненным циклом.

## [↑](#Содержание) Graceful Shutdown

- Обрабатывайте сигналы SIGTERM/SIGINT:
```js
process.on('SIGTERM', () => {
  server.close(() => {
    // закрыть соединения с БД, очередями и т.д.
    process.exit(0);
  });
});
```

- Дайте текущим запросам завершиться, не принимайте новые.

## [↑](#Содержание) Использование очередей (Message Queues)

- Для асинхронных операций (email, уведомления, обработка файлов) используйте RabbitMQ, Kafka, Redis Streams.
- Это делает систему более устойчивой к временным сбоям потребителей.

## [↑](#Содержание) Тестирование отказоустойчивости

- Проводите Chaos Engineering:
    - Имитируйте сбои сети (toxiproxy)
    - Убивайте процессы случайным образом
    - Тестируйте поведение при потере БД или внешнего API

## [↑](#Содержание) Архитектурные рекомендации

- Следуйте принципу "fail fast": если что-то пошло не так — быстро возвращайте ошибку, не держите ресурсы.
- Делайте сервисы stateless — состояние храните в БД или кэше.
- Избегайте блокирующих операций (синхронных вызовов, fs.readFileSync и т.п.).